
kiểm tra code bên dưới có đáp ứng các yêu cầu sau? Nếu không hãy chỉnh code:
- Thêm vào chức năng parse chú thích đầu file và nhét vào định dạng doxygen
- Nếu không tìn thấy doxygen chính thống nào thì bypass cái comment đó, không được xoá
- Xoá các xuống dòng phía sau đoạn comment doxygen
- Comment rất ngắn gọn, tiếng anh, doxygen, không tiếng việt
- Chỉ chỉnh sửa, các hàm có sẵn, không thêm bớt!
- Chức năng parse Definition: hoặc hàm nếu không có Definition:
- Xử lý kỹ các dấu xuống dòng, các indent để không thêm dư thừa. Lúc lấy đoạn comment từ input nếu có xóa thì phải ghi nhớ, sau khi generate doxygen comment thì phải trả lại toàn vẹn!
Ví dụ:
```
*=====================================================================================================================================
Definition: void the_function(uint8 the_param1, uint16* the_param2 )
Input Parameter: ADC grp number
Output Parameter: ADC values for corresponding group
Description: This function does the updates all the adc in a given group with the selected Diag sel line combination.
=======================================================================================================================================
```

Mong đợi các parametter sẽ được convert ra luôn (tức là lấy Input Parameter: ADC grp number làm chú thích chung cho cả 2):

```
/// @brief the_param1 ADC grp number
/// @brief the_param2 ADC grp number
```
- Phải so sánh định nghĩa hàm có đủ với số paramtter không, nếu k có đủ thì tức là chsu thích dùng chung!

CODE CŨ (__convert.hpp): 
```
#include <bits/stdc++.h>
#include <filesystem> 
#include <algorithm>

using namespace std;
namespace fs = std::filesystem;

#include "./__config.hpp"
#include "./__convertGlobalUtil.hpp"
#include "./__convertFileOperation.hpp"

enum state0_t {
    normal_code = 0,
    normal_comment,
    normal_comment_single_line,
    normal_comment_multi_line,
    doxygen_comment,
};

/// @brief Recursively scans the input directory for source files.
/// @details Filters for .h, .hpp, .c, .cpp extensions case-insensitively.
void scanFiles() {
    InputFilename.clear();
    
    if (!fs::exists(INPUT_ROOTDIR)) {
        cout << "[WARN] Directory " << INPUT_ROOTDIR << " does not exist.\n";
        return;
    }

    // Recursive directory iterator
    for (const auto& entry : fs::recursive_directory_iterator(INPUT_ROOTDIR)) {
        if (entry.is_regular_file()) {
            string ext = entry.path().extension().string();
            
            // Normalize extension to lowercase
            string ext_lower = ext;
            transform(ext_lower.begin(), ext_lower.end(), ext_lower.begin(), ::tolower);

            if (ext_lower == ".h" || ext_lower == ".hpp" || ext_lower == ".c" || ext_lower == ".cpp") {
                // Get relative path and normalize separators
                string relPath = fs::relative(entry.path(), INPUT_ROOTDIR).string();
                replace(relPath.begin(), relPath.end(), '\\', '/');
                InputFilename.push_back(relPath);
            }
        }
    }
}

void Print_Info(){
    printf("Input file paths:\n");
    for (auto s:InputFilename){
        cout << "\t -> " << INPUT_ROOTDIR << s << '\n';
    }
    printf("Output file paths:\n");
    for (auto s:InputFilename){
        cout << "\t <- " << OUTPUT_ROOTDIR << s << '\n';
    }
}

/// @brief Parses a Bosch-style comment block.
/// @details Detects File/Author/Date/Param/Return tags. 
///          Sets MASK_OTHERS if unstructured text (Copyright, Config) is found.
/// @param s Raw comment string.
/// @param brief Output for @brief/@file.
/// @param param Output for @param/@author/@date.
/// @param ret Output for @return.
/// @return Mask of found sections.
int parseBoschComent(string s, string &brief, vector<string> &param, string &ret) {
    const int maxEqualSymNum = 3;
    
    // Function Patterns
    const string pat_def    = "Definition:";
    const string pat_desc   = "Description:";
    const string pat_in     = "Input Parameter:";
    const string pat_in_div = "--";
    const string pat_out    = "Output Parameter:";
    
    // File Header Patterns
    const string pat_file1  = "File:";
    const string pat_file2  = "Filename:";
    const string pat_auth   = "Author:";
    const string pat_date   = "Date:";
    const string pat_ver    = "Version:";
    
    int currentSection = 0; // 0:Header/None, 1:Def, 2:In, 3:Out, 4:Desc
    int foundMask = MASK_NONE;

    // Store definitions found to map generic descriptions later
    vector<string> extractedParams; 
    string genericInputDesc = "";

    auto is_separator = [&](const string& line) -> bool {
        long countEq = count(line.begin(), line.end(), '=');
        return countEq > maxEqualSymNum;
    };

    auto clean_line = [&](string t) -> string {
        // Remove markers inside text
        string markers[] = {"//", "/*", "*/"};
        for (const auto& m : markers) {
            size_t pos;
            while ((pos = t.find(m)) != string::npos) t.replace(pos, m.length(), " ");
        }
        // Trim
        size_t first = t.find_first_not_of(" \t\n\r*/");
        if (string::npos == first) return "";
        size_t last = t.find_last_not_of(" \t\n\r");
        return t.substr(first, (last - first + 1));
    };

    // Lambda to extract parameter names from "void func(int a, float *b)"
    auto extract_params = [&](string defLine) {
        size_t openP = defLine.find('(');
        size_t closeP = defLine.find(')');
        if (openP != string::npos && closeP != string::npos && closeP > openP) {
            string args = defLine.substr(openP + 1, closeP - openP - 1);
            stringstream ssArg(args);
            string segment;
            while (getline(ssArg, segment, ',')) {
                // Get last token of the segment (variable name)
                string token, lastToken;
                stringstream ssToken(segment);
                while (ssToken >> token) lastToken = token;
                
                // Cleanup pointer chars like * or & from name
                lastToken.erase(remove(lastToken.begin(), lastToken.end(), '*'), lastToken.end());
                lastToken.erase(remove(lastToken.begin(), lastToken.end(), '&'), lastToken.end());
                
                if (!lastToken.empty() && lastToken != "void") {
                    extractedParams.push_back(lastToken);
                }
            }
        }
    };

    stringstream ss(s);
    string line;

    while (getline(ss, line)) {
        if (is_separator(line)) continue;

        // --- 1. HEADER TAG DETECTION ---
        if (line.find(pat_file1) != string::npos || line.find(pat_file2) != string::npos) {
            string p = (line.find(pat_file1) != string::npos) ? pat_file1 : pat_file2;
            string val = clean_line(line.substr(line.find(p) + p.length()));
            string tag = "/// @file " + val;
            brief = brief.empty() ? tag : tag + "\n" + brief;
            foundMask |= MASK_BRIEF; currentSection = 0; continue;
        }
        if (line.find(pat_auth) != string::npos) {
            string val = clean_line(line.substr(line.find(pat_auth) + pat_auth.length()));
            param.push_back("/// @author " + val);
            foundMask |= MASK_PARAM; currentSection = 0; continue;
        }
        if (line.find(pat_date) != string::npos) {
            string val = clean_line(line.substr(line.find(pat_date) + pat_date.length()));
            param.push_back("/// @date " + val);
            foundMask |= MASK_PARAM; currentSection = 0; continue;
        }
        if (line.find(pat_ver) != string::npos) {
            string val = clean_line(line.substr(line.find(pat_ver) + pat_ver.length()));
            param.push_back("/// @version " + val);
            foundMask |= MASK_PARAM; currentSection = 0; continue;
        }

        // --- 2. FUNCTION TAG DETECTION ---
        bool sectionChanged = false;
        if (line.find(pat_def) != string::npos) {
            currentSection = 1; sectionChanged = true;
            line = line.substr(line.find(pat_def) + pat_def.length());
        } else if (line.find(pat_in) != string::npos) {
            currentSection = 2; sectionChanged = true;
            line = line.substr(line.find(pat_in) + pat_in.length());
        } else if (line.find(pat_out) != string::npos) {
            currentSection = 3; sectionChanged = true;
            line = line.substr(line.find(pat_out) + pat_out.length());
        } else if (line.find(pat_desc) != string::npos) {
            currentSection = 4; sectionChanged = true;
            line = line.substr(line.find(pat_desc) + pat_desc.length());
        }

        string content = clean_line(line);
        if (content.empty()) continue;

        // --- 3. CONTENT PARSING ---
        switch (currentSection) {
            case 1: // Definition
            {
                // We found a definition line, extract params immediately
                extract_params(content); 
                // Do NOT mark as MASK_OTHERS, this is valid metadata
                break; 
            }
            case 2: // Input
            {
                size_t dPos = content.find(pat_in_div);
                if (dPos != string::npos) {
                    // Specific param: "Name -- Description"
                    string pName = clean_line(content.substr(0, dPos));
                    string pDesc = clean_line(content.substr(dPos + pat_in_div.length()));
                    param.push_back("/// @param " + pName + " " + pDesc);
                    foundMask |= MASK_PARAM;
                } else {
                    // No separator found. 
                    // If content isn't "None" or "void", treat as generic desc or param name without desc
                    if (content != "None" && content != "void") {
                         if (genericInputDesc.empty()) genericInputDesc = content;
                         else genericInputDesc += " " + content;
                    }
                }
                break;
            }
            case 3: // Output
            {
                if (content == "void" || content == "None") break;
                if (ret.empty()) ret = "/// @return " + content;
                else ret += " " + content;
                foundMask |= MASK_RET;
                break;
            }
            case 4: // Description
            {
                if (brief.empty()) brief = "/// @brief " + content;
                else brief += " " + content;
                foundMask |= MASK_BRIEF;
                break;
            }
            default:
                // Any text here that isn't a Tag is considered "Noise" 
                foundMask |= MASK_OTHERS; 
                break;
        }
    }

    // --- 4. POST PROCESSING: FILL GENERIC PARAMS ---
    if (!extractedParams.empty() && !genericInputDesc.empty()) {
        for (const string& pName : extractedParams) {
            // Check if this param was already documented specifically
            bool alreadyExists = false;
            for (const string& pTag : param) {
                if (pTag.find("@param " + pName) != string::npos) {
                    alreadyExists = true;
                    break;
                }
            }
            // If not documented, use the generic description
            if (!alreadyExists) {
                param.push_back("/// @param " + pName + " " + genericInputDesc);
                foundMask |= MASK_PARAM;
            }
        }
    }

    return foundMask;
}

/// @brief Converts file comments using state machine logic.
Status Convert(string finPath, string foutPath) {
    cout << "Convert " << finPath << " ---> " << foutPath << '\n';
    
    if (finOpen(finPath) != STATUS_OKE) return STATUS_ERR;
    if (foutOpen(foutPath) != STATUS_OKE) { finClose(); return STATUS_ERR; }

    int             state = normal_code;
    string          indent;
    char            c = 0;
    string          buffer;
    
    // Parser outputs
    string          doxygenBrief;
    string          doxygenReturn;
    vector<string>  doxygenParam;
    int             retMask = MASK_NONE;

    buffer.reserve(4096);

    do {
        c = finReadChar();
        if (c == 0 && finIsEOF()) { foutWriteBuffer(buffer); break; }
        if (c == 0) continue; 

        buffer.push_back(c);

        switch (state) {
            case normal_code:
                // Start of //
                if (c == '/' && buffer.size() >= 2 && buffer[buffer.size()-2] == '/') {
                    buffer.pop_back(); buffer.pop_back(); 
                    
                    // Capture Indent
                    indent.clear();
                    size_t last_nl = buffer.find_last_of('\n');
                    size_t start = (last_nl == string::npos) ? 0 : last_nl + 1;
                    for (size_t i = start; i < buffer.length(); ++i) {
                        if (buffer[i] == ' ' || buffer[i] == '\t') indent += buffer[i]; else break;
                    }

                    foutWriteBuffer(buffer); 
                    buffer.clear();
                    state = normal_comment_single_line;
                }
                // Start of /*
                else if (c == '*' && buffer.size() >= 2 && buffer[buffer.size()-2] == '/') {
                    buffer.pop_back(); buffer.pop_back(); 
                    
                    // Capture Indent
                    indent.clear();
                    size_t last_nl = buffer.find_last_of('\n');
                    size_t start = (last_nl == string::npos) ? 0 : last_nl + 1;
                    for (size_t i = start; i < buffer.length(); ++i) {
                        if (buffer[i] == ' ' || buffer[i] == '\t') indent += buffer[i]; else break;
                    }

                    foutWriteBuffer(buffer);
                    buffer.clear();
                    state = normal_comment_multi_line;
                }
                break;

            case normal_comment_single_line:
                if (c == '\n') {
                    buffer.pop_back(); // Remove newline
                    retMask = parseBoschComent(buffer, doxygenBrief, doxygenParam, doxygenReturn);

                    // LOGIC: Must have valid tags AND NO "Others" (Copyright, etc)
                    // Bypass check: if OTHERS is set, it's likely a license block or unsupported format
                    if ( (retMask & (MASK_BRIEF | MASK_PARAM | MASK_RET)) && !(retMask & MASK_OTHERS) ) {
                        // Convert
                        if (retMask & MASK_BRIEF) { foutWriteBuffer(indent); foutWriteBuffer(doxygenBrief); foutWriteChar('\n'); }
                        if (retMask & MASK_PARAM) { for (const auto& p : doxygenParam) { foutWriteBuffer(indent); foutWriteBuffer(p); foutWriteChar('\n'); } }
                        if (retMask & MASK_RET)   { foutWriteBuffer(indent); foutWriteBuffer(doxygenReturn); foutWriteChar('\n'); }
                        
                        // Eat newlines after Doxygen block
                        while (!finIsEOF()) {
                            int next_c = fin.peek();
                            if (next_c == '\n' || next_c == '\r') finReadChar(); else break; 
                        }
                    } else {
                        // Bypass (keep original)
                        foutWriteBuffer(indent); foutWriteBuffer("//"); foutWriteBuffer(buffer); foutWriteChar('\n'); 
                    }

                    doxygenBrief.clear(); doxygenParam.clear(); doxygenReturn.clear();
                    buffer.clear();
                    state = normal_code;
                }
                break;

            case normal_comment_multi_line:
                if (c == '/' && buffer.size() >= 2 && buffer[buffer.size()-2] == '*') {
                    buffer.pop_back(); buffer.pop_back();
                    retMask = parseBoschComent(buffer, doxygenBrief, doxygenParam, doxygenReturn);

                    // LOGIC: Must have valid tags AND NO "Others"
                    if ( (retMask & (MASK_BRIEF | MASK_PARAM | MASK_RET)) && !(retMask & MASK_OTHERS) ) {
                        // Convert
                        if (retMask & MASK_BRIEF) { foutWriteBuffer(indent); foutWriteBuffer(doxygenBrief); foutWriteChar('\n'); }
                        if (retMask & MASK_PARAM) { for (const auto& p : doxygenParam) { foutWriteBuffer(indent); foutWriteBuffer(p); foutWriteChar('\n'); } }
                        if (retMask & MASK_RET)   { foutWriteBuffer(indent); foutWriteBuffer(doxygenReturn); foutWriteChar('\n'); }

                        // Eat newlines after Doxygen block
                        while (!finIsEOF()) {
                            int next_c = fin.peek();
                            if (next_c == '\n' || next_c == '\r') finReadChar(); else break; 
                        }
                    } else {
                        // Bypass (keep original)
                        foutWriteBuffer(indent); foutWriteBuffer("/*"); foutWriteBuffer(buffer); foutWriteBuffer("*/"); 
                    }

                    doxygenBrief.clear(); doxygenParam.clear(); doxygenReturn.clear();
                    buffer.clear();
                    state = normal_code;
                }
                break;
        }
    } while (1);

    finClose(); foutClose();
    return STATUS_OKE;
}

void convertFromInputDir(){
    scanFiles();
    for (auto filename:InputFilename){
        string inFile = concat(INPUT_ROOTDIR, filename);
        string outFile = concat(OUTPUT_ROOTDIR, filename);
        fs::create_directories(fs::path(outFile).parent_path());
        Convert(inFile, outFile);
    }
}

void convertFromFilenameList(){
    for (auto filename:InputFilename){
         string outFile = concat(OUTPUT_ROOTDIR, filename);
         fs::create_directories(fs::path(outFile).parent_path());
         Convert(concat(INPUT_ROOTDIR, filename), outFile);
    }
}
```